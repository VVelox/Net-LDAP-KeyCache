#!/usr/local/bin/perl

use Mojolicious::Lite -signatures;
use File::Slurp;
use YAML::XS;
use TOML qw(from_toml);
use Web::ACL;
use Sys::Syslog;

sub verbose {
	my ( $level, $string ) = @_;

	if ( !defined($string) || $string eq '' ) {
		return;
	}

	if ( !defined($level) ) {
		$level = 'info';
	}

	openlog( 'mojo_nlkcc', undef, 'daemon' );
	syslog( $level, $string );
	closelog();

	return;
} ## end sub verbose

# read the config file in and figure out what to use for the socket
# as well as the Web::ACL file.
my $config_file = '/usr/local/etc/nlkcd.toml';
our $config;
my $err;
eval {
	my $config_raw = read_file($config_file);
	( $config, $err ) = from_toml($config_raw);
	unless ($config) {
		my $error_string = 'Error parsing "' . $config_file . '"... ' . $err;
		verbose( 'err', $error_string );
		die($error_string);
	}
};
if ($@) {
	my $error_string = 'Failed to read config, "' . $config_file . '"... ' . $@;
	verbose( 'err', $error_string );
	die($error_string);
}
if ( !defined( $config->{socket} ) ) {
	$config->{socket} = '/var/run/nlkcd/socket';
}
verbose( 'info', 'Socket: ' . $config->{socket} );
if ( !defined( $config->{webacl} ) ) {
	$config->{webacl} = '/usr/local/etc/webacl/nlkcd.yaml';
}
verbose( 'info', 'Web ACL YAML: ' . $config->{webacl} );

my $acl_config;
eval {
	my $raw_webacl = read_file( $config->{webacl} );
	$acl_config = Load($raw_webacl);
};
if ($@) {
	my $error_string = 'Failed reading or parsing Web ACL YAML, "' . $config->{webacl} . '"... ' . $@;
	verbose( 'err', $error_string );
	die($error_string);
}

our $acl;
eval { $acl = Web::ACL->new( acl => $acl_config ); };
if ($@) {
	my $error_string = 'Failed to create the Web::ACL object from, "' . $config->{webacl} . '"... ' . $@;
	verbose( 'err', $error_string );
	die($error_string);
}

get '/*' => sub ($c) {
	the_stuff($c);
};
get '/' => sub ($c) {
	the_stuff($c);
};

sub the_stuff {
	my $c         = $_[0];
	my $remote_ip = $c->{tx}{original_remote_address};

	# get and log basic initial info
	#
	# this is before type checking etc for the purpose of debugging
	verbose( 'info', 'Remote IP: ' . $remote_ip );
	my $apikey = $c->param('apikey');
	if ( !defined($apikey) ) {
		$apikey = 'undef';
	}
	verbose( 'info', 'API Key: ' . $apikey );

	# don't bother proceeding further as if we don't have a type, no reason to do anything else
	my $type = $c->param('type');
	if ( !defined($type) ) {
		$c->render( text => "No type specified", status => 400, );
		verbose( 'err', 'No type specified' );
		return;
	}
	verbose( 'info', 'Type: ' . $type );

	# type is used as the slug for the check
	my $acl_check;
	eval { $acl_check = $acl->check( apikey => $apikey, ip => $remote_ip, slugs => [$type], ); };
	if ($@) {
		$c->render( text => "backend error", status => 400, );
		verbose( 'err', 'Error checking the Web ACL object... ' . $@ );
		return;
	}
	if ( !$acl_check ) {
		$c->render( text => "unauthed", status => 403, );
		verbose( 'err',
			'Web ACL denied access for... apikey="' . $apikey . '" type="' . $type . '" ip="' . $remote_ip . '"' );
		return;
	}
	verbose( 'info',
		'Web ACL alloed access for... apikey="' . $apikey . '" type="' . $type . '" ip="' . $remote_ip . '"' );

	# generate the command string as well as get the various variables as well as make sure we have what we need
	my $search;
	my $key;
	my $val;
	my $command;
	if ( $type eq 'fetch' ) {
		$key = $c->param('key');
		$val = $c->param('val');

		if ( !defined($key) ) {
			$c->render( text => "No key specified", status => 400, );
			verbose( 'err', 'No key specified' );
			return;
		} elsif ( !defined($val) ) {
			$c->render( text => "No val specified", status => 400, );
			verbose( 'err', 'No val specified' );
			return;
		}
		verbose( 'info', 'Key: ' . $key );
		verbose( 'info', 'Val: ' . $val );

		$command = encode_json( { command => 'fetch', 'var' => $key, 'val' => $val } ) . "\n";
	} elsif ( $type eq 'search' ) {
		$search = $c->param('search');

		if ( !defined($search) ) {
			$c->render( text => "No search specified", status => 400, );
			verbose( 'err', 'No search specified' );
			return;
		}
		verbose( 'info', 'Search: ' . $search );

		$command = encode_json( { command => 'search', 'search' => $search, } ) . "\n";
	} elsif ( $type eq 'stats' ) {
		$command = encode_json( { command => 'stats' } ) . "\n";
	} elsif ( $type eq 'list_searches' ) {
		$command = encode_json( { command => 'list_searches' } ) . "\n";
	} else {
		$c->render( text => "Invalid type specified", status => 400, );
		verbose( 'err', 'Type "' . $type . '" is not understood' );
		return;
	}

	# if we have gotten this far, actually connect up
	my $socket;
	eval {
		$socket = IO::Socket::UNIX->new( Peer => $config->{socket}, Type => SOCK_STREAM(), Timeout => 10 )
			or die $@;
	};
	if ($@) {
		$c->render( text => "backend error", status => 400, );
		verbose( 'err', 'Unparsable connect to socket: ' . $@ );
		return;
	}

	eval { $socket->send($command); };
	if ($@) {
		$c->render( text => "backend error", status => 400, );
		verbose( 'err', 'Failed to send command to socket... ' . $@ );
		return;
	}
	my $data;
	eval { $data = read_socket_line($socket) || die('read_socket_line returned false'); };
	if ($@) {
		$c->render( text => "backend error", status => 400, );
		verbose( 'err', 'read_socket_line errored... ' . $@ );
		return;
	}
	$c->render( text => $data );

	eval { $socket->close; };
	if ($@) {
		verbose( 'err', '$socket->close errored... ' . $@ );
		return;
	}
} ## end sub the_stuff

app->start;
